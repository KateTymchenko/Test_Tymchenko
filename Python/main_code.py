# Modules to install
# pip install forex-python
# Task 1: The banks' statements are generated by code and saved to the 'banks_statements.csv' file.
# Task 2: Check if all operations are present in the company register. The result is saved in the
#         register_fullness.csv file generated by the code. The answer is "Yes" since all values in
#         the "is_present_in_register" column are True.
# Task 3: Commissions for some operations are incorrect, as indicated in the "is_correct_commission"
#         column of the commissions.csv file. However, the discrepancies in the commissions are
#         relatively minor.
# Task 4: The financial report data is generated in the financial_report.xlsx file and divided into
#         different sheets, "Report 1" and "Report 2." These reports are also displayed in the terminal.


import pandas as pd
import zipfile
import csv
import openpyxl
import os
import sys

import io
from detect_delimiter import detect
from itertools import islice
from datetime import datetime
from forex_python.converter import CurrencyCodes


def main():

    #### TASK 1 ####

    # Read the banks' data
    # Initialize empty lists to store data from the zip files
    account_name = []
    datetime = []
    transaction_id = []
    provider_name = []
    client_name = []
    currency = []
    debit = []
    credit = []
    commission = []
    description = []

    # Unzip the file 'employee_task_statements.zip'
    with zipfile.ZipFile("employee_task_statements.zip") as myzip:
        for file in myzip.namelist():
            # Detect the delimiter (',' or ';') by analyzing the file's content
            with myzip.open(file) as f0:
                del_1 = 0
                del_2 = 0
                for line in f0:
                    del_1 += str(line).count(",")
                    del_2 += str(line).count(";")
                # Choose the delimiter with more occurrences
                if del_1 > del_2:
                    del_ = ","
                else:
                    del_ = ";"

            # Read the file and skip the first 5 lines to get the header from the 6th line
            with myzip.open(file, "r") as f:
                reader = csv.reader(io.TextIOWrapper(f), delimiter=del_)
                iterator = islice(reader, 5, None)
                headers = next(iterator)

            # Read the file again to parse the data using the detected header
            with myzip.open(file, "r") as f1:
                dict_reader = csv.DictReader(
                    io.TextIOWrapper(f1, encoding="utf-8"),
                    delimiter=del_,
                    fieldnames=headers,
                )

                # Skip the first 5 lines and start reading data
                iterator1 = islice(dict_reader, 5, None)

                # Loop through each row in the file
                for col in iterator1:
                    # Append the values to respective lists
                    account_name.append(col["account_name"])
                    datetime.append(col["datetime"])
                    transaction_id.append(col["transaction_id"])
                    provider_name.append(col["provider_name"])
                    client_name.append(col["client_name"])
                    currency.append(col["currency"])
                    commission.append(col["commission"])

                    # Validate fields from various files to ensure consistency in common columns
                    # Handle credit and debit fields based on the 'Debi/Credit' column
                    if "Debi/Credit" in col:
                        if col["Debi/Credit"] == "D":
                            debit.append(col["amount"])
                            credit.append(0)
                        elif col["Debi/Credit"] == "C":
                            credit.append(col["amount"])
                            debit.append(0)

                    # Append debit and credit values if they exist
                    if "debit" in col:
                        debit.append(col["debit"])
                    if "credit" in col:
                        credit.append(col["credit"])

                    # Handle description or payment info fields
                    if "payment info" in col:
                        description.append([col["payment info"]])
                    elif "description" in col:
                        description.append([col["description"]])

    # Create a DataFrame from the lists
    df = pd.DataFrame(
        {
            "account_name": account_name,
            "datetime": datetime,
            "transaction_id": transaction_id,
            "provider_name": provider_name,
            "client_name": client_name,
            "currency": currency,
            "credit": credit,
            "debit": debit,
            "commission": commission,
            "description": description,
        }
    )

    # Replace the ',' symbol in 'commission' with a '.' for proper numeric parsing
    df["commission"] = df["commission"].str.replace(",", ".", regex=False)

    # Convert the description list to a string, removing brackets
    df["description"] = df["description"].apply(lambda x: ", ".join(x))

    # Perform Validation
    print("Task 1:")
    perform_validation(df, "Merging and Validating Banks' Records")

    # Casting columns to desired types
    df = df.astype(
        {
            "account_name": "string",
            "datetime": "datetime64[ns]",  # datetime type
            "transaction_id": "string",
            "provider_name": "string",
            "client_name": "string",
            "currency": "string",
            "credit": "float64",  # casting numeric columns to float
            "debit": "float64",  # casting numeric columns to float
            "commission": "float64",  # casting numeric columns to float
            "description": "string",
        }
    )

    # Read the 'register' file into a DataFrame
    register = pd.read_csv("register.csv")
    register["provider_name"] = register["provider_name"].astype(str)

    # Perform Validation
    perform_validation(register, "Register Validation")

    # Save the validated banks statements to 'banks_statements.csv'
    # check if file exists
    try:
        if os.path.exists("banks_statemetns.csv"):
            os.remove("banks_statemetns.csv")
        df.to_csv("banks_statemetns.csv", index=False)
        print(
            "The banks' statements are generated by code and saved to the 'banks_statements.csv' file."
        )
    except PermissionError:
        # Raise an error with if permission is denied
        print(
            f"Permission denied: The file banks_statemetns.csv might be open in another program or you don't have write access."
        )

    #### TASK 2 ####

    # Casting columns to desired types
    register = register.astype(
        {
            "account_name": "string",
            "datetime": "datetime64[ns]",  # datetime type
            "transaction_id": "string",
            "provider_id": "string",
            "provider_name": "string",
            "operation_type": "string",
            "currency": "string",
            "amount": "float64",  # casting numeric columns to float
            "commission": "float64",  # casting numeric columns to float
            "commentary": "string",
        }
    )

    # Prepare the `account_name` column by removing the first 4 characters
    register["account_name"] = register["account_name"].str[:-4]

    # Sort the DataFrame by 'client_name', 'provider_name', 'currency', and 'datetime'
    df = df.sort_values(by=["client_name", "provider_name", "currency", "datetime"])

    # Group by 'client_name', 'provider_name', 'currency' and get the next row's 'debit' value
    df["next_debit"] = df.groupby(["client_name", "provider_name", "currency"])[
        "debit"
    ].shift(-1)
    # Group by 'client_name', 'provider_name', 'currency' and get the next row's 'commission' value
    df["next_commission"] = df.groupby(["client_name", "provider_name", "currency"])[
        "commission"
    ].shift(-1)

    # Identify the rows where the 'credit' matches the next row's 'debit'
    matching_rows = df["credit"] == df["next_debit"]

    # Replace the 'commission' column with the next commission value where a match is found
    df.loc[matching_rows, "commission"] = df.loc[matching_rows, "next_commission"]

    # Drop the 'next_commission' and 'next_debit' columns as it's no longer needed
    df = df.drop(columns=["next_commission", "next_debit"])

    # Filter df to include only rows where credit > 0
    df = df[df["credit"] > 0]

    # Perform the left join based on the conditions
    merged_df = pd.merge(
        df,
        register,
        how="left",
        left_on=["client_name", "provider_name", "currency", "credit", "datetime"],
        right_on=["account_name", "provider_name", "currency", "amount", "datetime"],
        suffixes=("_banks", "_register"),
    )

    # Add "is_present_in_register" column to indicate if the transaction was found
    merged_df["is_present_in_register"] = ~merged_df["transaction_id_register"].isna()

    # Drop excess columns
    merged_df = merged_df.drop(
        columns=[
            "commission_register",
            "credit",
            "debit",
            "commentary",
            "account_name_register",
        ]
    )

    # Save the register fullness result to 'register_fullness.csv'
    # check if file exists
    try:
        if os.path.exists("register_fullness.csv"):
            os.remove("register_fullness.csv")
        merged_df.to_csv("register_fullness.csv", index=False)
    except PermissionError as e:
        # Raise an error with if permission is denied
        print(
            f"Permission denied: The file register_fullness.csv might be open in another program or you don't have write access."
        )
        sys.exit()

    # Print the result
    print("\nTask 2:")
    print("All banks' operations are present in the company register\n")

    #### TASK 3 ####

    # Generate tables with given commissions

    # Define the data for each bank with currency as a separate column
    data_green_field = {
        "currency": ["USD", "EUR"],
        "price_per_month": [100.000, 80.000],
        "min_deposit": [200.000, 0.000],
        "payout_price": [0.015, 0.013],
        "payin_price": [0.000, 0.000],
    }
    df_green_field = pd.DataFrame(data_green_field)
    df_green_field["bank"] = "Green Field"

    data_gold_fix = {
        "currency": ["USD", "EUR"],
        "price_per_month": [110.000, 87.000],
        "min_deposit": [220.000, 0.000],
        "payout_price": [0.016, 0.014],
        "payin_price": [0.000, 0.000],
    }
    df_gold_fix = pd.DataFrame(data_gold_fix)
    df_gold_fix["bank"] = "Gold Fix"

    data_company_terms = {
        "currency": ["USD", "EUR"],
        "price_per_month": [250.000, 230.000],
        "min_deposit": [500.000, 460.000],
        "payout_price": [0.025, 0.022],
        "payin_price": [0.000, 0.000],
    }
    df_company_terms = pd.DataFrame(data_company_terms)
    df_company_terms["bank"] = "Best Company"

    # Merge all dataframes
    dictionary_terms = pd.concat(
        [df_green_field, df_gold_fix, df_company_terms], ignore_index=True
    )

    # Perform the left join based on the conditions
    check_commissions = pd.merge(
        merged_df,
        dictionary_terms,
        how="left",
        left_on=["provider_name", "currency"],
        right_on=["bank", "currency"],
        suffixes=("_operations", "_dict"),
    )

    # Add fact commissions
    check_commissions["bank_fact_commission"] = (
        check_commissions["commission_banks"] / check_commissions["amount"]
    )

    # Add commissions from dictionary
    check_commissions["dict_commissions"] = check_commissions["payout_price"]

    # Cast column types in a DataFrame
    check_commissions = check_commissions.astype(
        {
            "bank_fact_commission": "float64",  # casting numeric columns to float
            "dict_commissions": "float64",  # casting numeric columns to float
        }
    )

    # Check the correctness of commissions
    check_commissions["is_correct_commission"] = (
        check_commissions["bank_fact_commission"]
        == check_commissions["dict_commissions"]
    )

    # Drop excess columns
    check_commissions = check_commissions.drop(
        columns=[
            "price_per_month",
            "min_deposit",
            "payout_price",
            "payin_price",
            "bank",
        ]
    )

    # Save the register fullness result to 'register_fullness.csv'
    # check if file exists
    try:
        if os.path.exists("commissions.csv"):
            os.remove("commissions.csv")
        check_commissions.to_csv("commissions.csv", index=False)
    except PermissionError:
        # Raise an error with if permission is denied
        print(
            f"Permission denied: The file commissions.csv might be open in another program or you don't have write access."
        )
        sys.exit()

    # Print the results
    print("Task 3:")
    print(
        "Commissions for some operations are incorrect, as indicated in the 'is_correct_commission' column\nof the 'commissions.csv' file. However, the discrepancies in the commissions are relatively minor.\nIt is noteworthy that there are absent customer payments for using the company account in February."
    )

    #### TASK 4 ####

    # Select only the necessary columns from check_commissions
    check_commissions_subset = check_commissions[
        ["transaction_id_register", "commission_banks"]
    ]

    # Merge the register with the subset of bank statements based on transaction_id

    f = pd.merge(
        register,
        check_commissions_subset,
        how="left",
        left_on=["transaction_id"],
        right_on=["transaction_id_register"],
        suffixes=("_register", "_banks"),
    )

    # Merge the resulting data with dictionary terms based on provider_name and currency
    fin = pd.merge(
        f,
        dictionary_terms,
        how="left",
        left_on=["provider_name", "currency"],
        right_on=["bank", "currency"],
        suffixes=("_operations", "_dict"),
    )

    fin["client"] = fin["account_name"].str.split("_").str[0]

    # Drop the 'transaction_id_register', 'payin_price', and 'bank' columns as they are no longer needed
    fin = fin.drop(columns=["transaction_id_register", "payin_price", "bank"])

    # Replace missing values in 'price_per_month' with 0
    fin["price_per_month"] = fin["price_per_month"].fillna(0)

    # Convert 'datetime' to pandas datetime format
    fin["datetime"] = pd.to_datetime(fin["datetime"])

    # Extract Month and Year from datetime and create a new 'year_month' column
    fin["year_month"] = fin["datetime"].dt.to_period("M")

    # Create new 'income' column based on operation type
    fin["income"] = fin.apply(
        lambda x: (
            x["amount"]
            if x["operation_type"] == "income"
            else x["commission"] if x["operation_type"] == "outcome" else 0
        ),
        axis=1,
    )

    # Create new 'outcome' column based on operation type
    fin["outcome"] = fin.apply(
        lambda x: (
            x["commission_banks"]
            if x["operation_type"] == "income"
            else (
                x["amount"]
                if x["operation_type"] == "outcome"
                and x["provider_name"] != "Best Company"
                else 0
            )
        ),
        axis=1,
    )

    # Create 'income_operations' column based on operation type
    fin["income_operations"] = fin.apply(
        lambda x: x["amount"] if x["operation_type"] == "income" else 0, axis=1
    )

    # Create 'income_commissions' column based on operation type
    fin["income_commissions"] = fin.apply(
        lambda x: x["commission"] if x["operation_type"] == "outcome" else 0, axis=1
    )

    # Create 'outcome_operations' column based on operation type
    fin["outcome_operations"] = fin.apply(
        lambda x: (
            x["amount"]
            if x["operation_type"] == "outcome" and x["provider_name"] != "Best Company"
            else 0
        ),
        axis=1,
    )

    # Create 'outcome_commissions' column based on operation type
    fin["outcome_commissions"] = fin.apply(
        lambda x: x["commission_banks"] if x["operation_type"] == "income" else 0,
        axis=1,
    )

    # Create 'outcome_service_banks' column
    fin["outcome_service_banks"] = fin.apply(
        lambda x: (
            x["price_per_month"]
            if x["provider_name"] in ("Gold Fix", "Green Field")
            else 0
        ),
        axis=1,
    )

    # Create 'income_service_customers' column
    fin["income_service_customers"] = fin.apply(
        lambda x: x["price_per_month"] if x["provider_name"] == "Best Company" else 0,
        axis=1,
    )

    # Group data by year_month, provider_name, and currency and aggregate the relevant columns
    fin_banks = (
        fin.groupby(["year_month", "provider_name", "currency"])
        .agg(
            income_operations=("income_operations", "sum"),
            income_commissions=("income_commissions", "sum"),
            income_service_customers=("income_service_customers", "sum"),
            income_not_full=("income", "sum"),
            outcome_operations=("outcome_operations", "sum"),
            outcome_commissions=("outcome_commissions", "sum"),
            outcome_service_banks=("outcome_service_banks", "max"),
            outcome_not_full=("outcome", "sum"),
        )
        .reset_index()
    )

    # Calculate the total outcome
    fin_banks["outcome"] = (
        fin_banks["outcome_not_full"] + fin_banks["outcome_service_banks"]
    )

    # Calculate the total income
    fin_banks["income"] = (
        fin_banks["income_not_full"] + fin_banks["income_service_customers"]
    )

    # Drop 'outcome_not_full' and 'income_not_full' columns
    fin_banks = fin_banks.drop(columns=["outcome_not_full", "income_not_full"])

    # Report 1: Company Monthly Income and Outcome Breakdown by Currency
    turnover = (
        fin_banks.groupby(["year_month", "currency"])
        .agg(
            income=("income", "sum"),
            outcome=("outcome", "sum"),
        )
        .reset_index()
    )

    # Calculate the balance for each month and currency
    turnover["balance"] = turnover["income"] - turnover["outcome"]
    report_1_name = "Company Monthly Income and Outcome Breakdown by Currency"

    # Save the report's data to 'reports_financial_banks_base.csv'
    # check if file exists
    try:
        if os.path.exists("reports_financial_banks_base.csv"):
            os.remove("reports_financial_banks_base.csv")
        fin_banks.to_csv("reports_financial_banks_base.csv", index=False)
    except PermissionError:
        # Raise an error with if permission is denied
        print(
            f"Permission denied: The file reports_financial_banks_base.csv might be open in another program or you don't have write access."
        )
        sys.exit()

    # Display Report 1
    print("\nTask 4:")
    print(
        "The data for the visualization is saved to 'reports_financial_banks_base.csv'."
    )
    print(report_1_name + "\n")
    print(turnover)

    # Report 2: Company Monthly Income and Expense Breakdown by Currency and Type
    turnover_type = (
        fin_banks.groupby(["year_month", "currency"])
        .agg(
            income_operations=("income_operations", "sum"),
            income_commissions=("income_commissions", "sum"),
            income_service_customers=("income_service_customers", "sum"),
            outcome_operations=("outcome_operations", "sum"),
            outcome_commissions=("outcome_commissions", "sum"),
            outcome_service_banks=("outcome_service_banks", "max"),
        )
        .reset_index()
    )

    # Melt the DataFrame
    turnover_type_melted = pd.melt(
        turnover_type,
        id_vars=["year_month", "currency"],
        value_vars=[
            "income_operations",
            "income_commissions",
            "outcome_operations",
            "outcome_commissions",
            "outcome_service_banks",
        ],
        var_name="type",
        value_name="amount",
    )

    # Sort the melted DataFrame by year_month, currency, and type
    turnover_type = turnover_type_melted.sort_values(
        by=["year_month", "currency", "type"]
    )

    # Reset the index to start from 0 and then adjust to start from 1
    turnover_type = turnover_type.reset_index(drop=True)
    turnover_type.index = turnover_type.index + 1

    report_2_name = "Company Monthly Income and Expense Breakdown by Currency and Type"

    # Display Report 2
    print("\n" + report_2_name + "\n")
    print(turnover_type)

    # Save two reports to different excel sheets to financial_report.xlsx
    try:
        if os.path.exists("financial_report.xlsx"):
            os.remove("financial_report.xlsx")
        with pd.ExcelWriter("financial_report.xlsx") as writer:
            turnover.to_excel(
                writer, sheet_name="Report 1", index=False, header=True, startrow=2
            )
            turnover_type.to_excel(
                writer, sheet_name="Report 2", index=False, header=True, startrow=2
            )

        # Open the workbook to add the headers
        wb = openpyxl.load_workbook("financial_report.xlsx")
        ws1 = wb["Report 1"]
        ws2 = wb["Report 2"]

        # Insert "Report" in the first row
        ws1["A1"] = "Company Monthly Income and Outcome Breakdown by Currency"
        ws2["A1"] = "Company Monthly Income and Expense Breakdown by Currency and Type"

        # Save the changes
        wb.save("financial_report.xlsx")

    except PermissionError:
        # Raise an error with if permission is denied
        print(
            f"Permission denied: The file financial_report.xlsx might be open in another program or you don't have write access."
        )
        sys.exit()

    print(
        "\nFinancial reports have been generated and saved to 'financial_report.xlsx'."
    )


# Define validation functions to check each field's format and value


def validate_account_name(name):
    # Check if account_name is not empty and is a string
    return isinstance(name, str) and len(name) > 0


def validate_datetime(date_str):
    # Validate datetime format 'YYYY-MM-DD HH:MM:SS'
    try:
        datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
        return True
    except ValueError:
        return False


def validate_transaction_id(tid):
    # Check if transaction_id is a non-empty string
    return isinstance(tid, str) and len(tid) > 0


def validate_provider_name(name):
    # Check if provider_name is a string
    return isinstance(name, str)


def validate_client_name(name):
    # Check if client_name is not empty and is a string
    return isinstance(name, str)


def validate_currency(currency):
    # Check if currency is in a list of valid currencies
    currency_codes = CurrencyCodes()
    return currency_codes.get_currency_name(currency) is not None


def validate_amount(value):
    # Check if the value is a float or can be converted to a float
    try:
        float(value)
        return True
    except ValueError:
        return False


def validate_description(desc):
    # Check if description is a string (it can be empty)
    return isinstance(desc, str)


def validate_operation_type(op_type):
    # Check if operation_type is either 'outcome' or 'income'
    return op_type in ["outcome", "income"]


def validate_commentary(commentary):
    # Check if commentary is a string (it can be empty)
    return isinstance(commentary, str)


def validate_provider_id(provider_id):
    # Check if the value is a float or can be converted to a float
    try:
        float(provider_id)
        return True
    except ValueError:
        return False


# Perform validation
def perform_validation(df, df_type):
    validation_errors = []

    for index, row in df.iterrows():
        if not validate_account_name(row["account_name"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid account_name '{row['account_name']}'"
            )

        if not validate_datetime(row["datetime"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid datetime '{row['datetime']}'"
            )

        if not validate_transaction_id(row["transaction_id"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid transaction_id '{row['transaction_id']}'"
            )

        if not validate_provider_name(row["provider_name"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid provider_name '{row['provider_name']}'"
            )

        if not validate_currency(row["currency"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid currency '{row['currency']}'"
            )

        if "provider_id" in row and not validate_provider_id(row["provider_id"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid provider_id '{row['provider_id']}'"
            )

        if "operation_type" in row and not validate_operation_type(
            row["operation_type"]
        ):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid operation_type '{row['operation_type']}'"
            )

        if "amount" in row and not validate_amount(row["amount"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid amount '{row['amount']}'"
            )

        if "debit" in row and not validate_amount(row["debit"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid debit '{row['debit']}'"
            )

        if "credit" in row and not validate_amount(row["credit"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid credit '{row['credit']}'"
            )

        if not validate_amount(row["commission"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid commission '{row['commission']}'"
            )

        if "commentary" in row and not validate_commentary(row["commentary"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid commentary '{row['commentary']}'"
            )

        if "client_name" in row and not validate_client_name(row["client_name"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid client_name '{row['client_name']}'"
            )

        if "description" in row and not validate_description(row["description"]):
            validation_errors.append(
                f"{df_type} Row {index}: Invalid description '{row['description']}'"
            )

    if validation_errors:
        print(f"{df_type}: Validation errors found:")
        for error in validation_errors:
            print(error)
    else:
        print(f"{df_type}: All data has been uploaded and is valid.")


# Entry point of the script
if __name__ == "__main__":
    main()
